from abc import ABC
from typing import List, Optional, Tuple, Union


class MathBackendInterface(ABC):
    def conj(self, array): ...

    def diag(self, array): ...

    def reshape(self, array, shape): ...

    def sum(self, array, axis=None): ...

    def arange(self, start, limit=None, delta=1): ...

    def outer(self, arr1, arr2): ...

    def identity(self, size: int): ...

    def zeros(self, shape: Union[int, Tuple[int, ...]], dtype): ...

    def abs(self, array): ...

    def trace(self, array): ...

    def tensordot(self, a, b, axes, dtype=None): ...

    def transpose(self, a, perm): ...

    def block(self, blocks: List[List]): ...

    def concat(self, values, axis): ...

    def norm(self, array): ...

    def add(self, old, new: Optional[Tensor], modes: List[int]): ...

    def sandwich(self, bread: Optional[Tensor], filling, modes: List[int]): ...

    def matvec(self, mat: Optional[Tensor], vec, modes: List[int]): ...

    def new_symplectic_parameter(
        self,
        init_value: Optional[Tensor] = None,
        trainable: bool = True,
        num_modes: int = 1,
        name: str = "symplectic",
    ):
        ...

    def unitary_to_orthogonal(self, U):
        ...

    def new_euclidean_parameter(
        self,
        init_value: Optional[Union[float, List[float]]] = None,
        trainable: bool = True,
        bounds: Tuple[Optional[float], Optional[float]] = (None, None),
        shape: Optional[Sequence[int]] = None,
        name: str = "",
    ):
        ...

    def poisson(self, max_k: int, rate):
        ...

    def binomial_conditional_prob(self, success_prob, dim_out: int, dim_in: int):
        ...

    def convolve_probs_1d(self, prob, other_probs: List):
        ...

    def convolve_probs(self, prob, other):
        ...