from abc import ABC
from mrmustard.typing import *


class BackendInterface(ABC):
    r"""
    The interface that all backends must implement.
    All methods are pure (no side effects) and are be used by the plugins.
    """

    # ~~~~~~~~~~~~~~
    # Low level math
    # ~~~~~~~~~~~~~~

    def conj(self, x: Numeric) -> Numeric: ...

    def diag(self, a: Array) -> Array: ...

    def diag_part(self, a: Array) -> Array: ...

    def reshape(self, a: Array, shape) -> Array: ...

    def sum(self, a: Array, axis=None) -> Numeric: ...

    def arange(self, start: int, limit: int, delta: int) -> Generator: ...

    def outer(self, a: Array, b: Array) -> Array: ...

    def identity(self, size: int) -> Matrix: ...

    def zeros(self, shape: Sequence[int], dtype) -> Array: ...

    def zeros_like(self, a: Array) -> Array: ...

    def ones(self, shape: Sequence[int], dtype) -> Array: ...

    def ones_like(self, array: Array) -> Array: ...

    def abs(self, x: Numeric) -> Numeric: ...

    def trace(self, a: Array) -> Numeric: ...

    def xxpp_trace(self, a: Array) -> Scalar: ...

    def tensordot(self, a: Array, b: Array, axes: Sequence[int]) -> Array: ...

    def transpose(self, a: Array, perm: Sequence[int]) -> Array: ...

    def block(self, blocks: List[List[Array]]) -> Array: ...

    def concat(self, seq: Sequence[Array], axis: Sequence[int]): ...

    def norm(self, x: Numeric, dtype) -> Scalar: ...

    def unitary_to_orthogonal(self, U: Matrix) -> Matrix: ...

    def poisson(self, max_k: int, rate: Scalar) -> Vector: ...

    def binomial_conditional_prob(self, success_prob: Scalar, dim_out: int, dim_in: int) -> Matrix: ...

    def convolve_probs_1d(self, prob: Array, other_probs: List[Vector]) -> Array: ...

    def convolve_probs(self, prob: Array, other: Array) -> Array: ...
